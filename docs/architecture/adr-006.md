## ADR-006: Command Dispatcher Architecture

**Status:** Accepted  
**Date:** 2025-10-14

### Context

Early prototypes handled CLI flags and execution directly inside `main.go`. The branching logic grew quickly, mixing flag parsing, dependency graph construction, orchestration, and output formatting in one place. Adding new workflows such as drift detection or lock inspection became risky because there was no clear separation between command wiring and execution logic.

### Decision

Adopt a modular command architecture built on Cobra:

- Each CLI command lives in `cmd/terraform-wrapper/commands`.
- Command handlers delegate to packages under `internal/` (executor, graph, cache, lock, output, stacks).
- Shared options and helpers reside in `root.go` to keep subcommands thin.

Directory layout:

```
cmd/
  terraform-wrapper/
    commands/
      apply.go
      destroy.go
      init.go
      plan.go
      plan_all.go
      bootstrap.go
internal/
  executor/
  graph/
  cache/
  lock/
  output/
  stacks/
```

### Rationale

- Keeps CLI wiring declarative while pushing behaviour into testable packages.
- Makes it straightforward to introduce new commands without editing a monolithic switch.
- Aligns with Go ecosystem conventions, lowering the learning curve for contributors.

### Alternatives Considered

- Custom flag parsing in `main.go`: minimal dependencies but unscalable for multi-command UX.
- Subcommand registration via reflection: reduced boilerplate, but less explicit and harder to reason about.

### Consequences

- Easier to add capabilities (e.g., `plan-all`, `clean`) with predictable structure.
- More boilerplate upfront, because every command needs a file and options plumbing.
- Shared logic is reusable in tests, improving coverage and reliability.
