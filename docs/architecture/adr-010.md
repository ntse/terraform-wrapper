## ADR-010: Stack Dependency Declarations

**Status:** Accepted  
**Date:** 2025-10-14

### Context

Terraform manages dependencies within a workspace but has no concept of ordering across multiple stacks. To orchestrate plans and applies across environments we needed a consistent way to describe upstream relationships. Existing tools such as Terragrunt provide opinions, yet adopting them wholesale would constrain the wrapperâ€™s design and introduce additional configuration languages.

### Decision

Represent stack relationships with a lightweight `dependencies.json` file committed alongside each stack. Example:

```
{
  "dependencies": {
    "paths": [
      "./core-services/network",
      "./core-services/bootstrap"
    ]
  }
}
```

The wrapper scans for these files, resolves relative paths, and constructs a Directed Acyclic Graph that feeds execution ordering and the superplan generator.

### Rationale

- JSON is simple to diff and can be parsed without external dependencies.
- Keeping dependency metadata inside the stack directory makes it clear when dependencies change as part of a pull request.
- Explicit declarations avoid hidden coupling and enable validation of cycles up front.

### Alternatives Considered

- Terragrunt dependency blocks: comprehensive but would require adopting Terragrunt (rejected in ADR-009).
- Hard-coded CI pipelines: workable for small estates but brittle as stacks evolve.
- Embedding dependencies in Terraform modules: leaks infrastructure concerns into application code.

### Consequences

- Additional file to maintain per stack; stale entries can still cause orchestration failures until corrected.
- Enables the wrapper to compute deterministic execution order and detect dependency cycles early.
- Aligns with the superplan feature, which relies on the same graph when merging state.
