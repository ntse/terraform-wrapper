## ADR-004: S3 Object Lock for Orchestration-Level Locking

**Status:** Accepted  
**Date:** 2025-10-14

### Context

Terraformâ€™s built-in state locking protects individual workspaces, but multi-stack operations such as `plan-all` need a higher-level guard. Without a shared lock, separate runners can overlap, producing conflicting superplans or racing on shared artefacts.

### Decision

Create a dedicated orchestration lock stored in S3:

- Object path: `s3://<account>-<region>-state/locks/<environment>/superplan-lock.json`
- Acquisition: conditional PUT with `If-None-Match: *`
- Payload: metadata describing owner, timestamp, command, and environment
- Release: remove object at completion; expired entries are cleaned up by a TTL process

### Rationale

- Reuses our existing S3 state bucket and IAM policies, so no new infrastructure is required.
- S3 Object Lock semantics give atomicity for acquisition and work across regions used by our stacks.
- A JSON payload keeps troubleshooting simple when we need to inspect who owns a lock.

### Alternatives Considered

- DynamoDB coordination: strong guarantees, but introduces another managed service and IAM surface.
- Relying on Terraform state locking alone: insufficient because it cannot coordinate cross-stack workflows.
- Local filesystem locks on runners: fragile in distributed CI environments.

### Consequences

- Prevents concurrent environment-wide orchestration runs that would otherwise collide.
- Requires explicit cleanup after interrupted jobs; stale locks will block new runs until purged.
- Users running vanilla Terraform without the wrapper can still bypass the lock and create inconsistent plans.
